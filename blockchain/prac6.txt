PRACTICAL NO : 6


Implement and demonstrate the use of the following in Solidity :
(I).Functions
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract functions {
 function testpgmresult() public pure returns (uint) {
 uint a = 1000; // local variable
 uint b = 2000;
 uint result = a + b;
 return result;
 }
}

(II).View Functions


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract viewfunction {
 function getResult() public pure returns (uint product, 
uint sum) {
 uint a = 1; // local variable
 uint b = 2;
 product = a * b;
 sum = a + b;
 }
}



(III).Pure Functions


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract C {
 // private state variable
 uint private data;
 // public state variable
 uint public info;
 // constructor
 constructor() public {
 info = 10;
 }
 // private function
 function increment(uint a) private pure returns (uint) {
 return a + 1;
 }
 // public function
 function updateData(uint a) public {
 data = a;
 }
 function getData() public view returns (uint) {
 return data;
 }
 function compute(uint a, uint b) internal pure returns 
(uint) {
 return a + b;
 }
}
// Derived Contract
contract E is C {
 uint private result;
 C private c;
 constructor() public {
 c = new C();
 }
 function getComputedResult() public {
 result = compute(3, 5);
 }
 function getResult() public view returns (uint) {
 return result;
 }
 function getDataFromC() public view returns (uint) {
 return c.info();
 }
}
OUTPUT:
(IV).Function Overloading
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract functionoverloading {
 function getSum(uint a, uint b) public pure returns(uint) 
{
 return a + b;
 }
 function getSumWithThreeArguments(uint a, uint b, uint c) 
public pure returns(uint) {
 return a + b + c;
 }
 function callSumWithTwoArguments() public pure 
returns(uint) {
 return getSum(1, 2);
 }
 function callSumWithThreeArguments() public pure 
returns(uint) {
 return getSumWithThreeArguments(1, 2, 3);
 }
}
OUTPUT:
(V).Mathematical Functions
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract mathematicalfunction {
 function callAddMod() public pure returns(uint) {
 return addmod(4, 5, 3); // Computes (4 + 5) % 3 = 6 % 
3 = 0
 }
 function callMulMod() public pure returns(uint) {
 return mulmod(4, 5, 3); // Computes (4 * 5) % 3 = 20 
% 3 = 2
 }
}


(VI).Cryptographic Functions


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract cryptographicfunction {
 function callSha256() public pure returns(bytes32 result) 
{
 return sha256("ronaldo");
 }
 function callKeccak256() public pure returns(bytes32 
result) {
 return keccak256("ronaldo");
 }
}